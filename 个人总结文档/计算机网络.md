#### Http和Https的区别

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
- 端口不同：Http与Https使用不同的连接方式，用的端口也不一样，前者是80，后者是443
- 资源消耗：和HTTP通信相比，Https通信会由于加解密处理消耗更多的CPU和内存资源
- 开销：Https通信需要证书，而证书一般需要向认证机构购买
  Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制



#### 三次握手

基本概念:

**syn**: 同步序列编号；**ack**：确认字符；**seq**：序列号 

三次握手可以简单描述为：我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，连接成功具体过程如下：

- 第一次握手：客户端将标志位SYN置为1，随机产生一个序号值为seq=J，并将该数据包发送给Server，Client进入SYN_SEND状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，确认序号ack=J+1，同时自己也随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
  

![](F:\前端总结\个人总结文档\img\1.jpg)

#### 四次挥手

四次挥手可以简单描述为：我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧

- 第一次挥手：Client发送一个**FIN=1**，确认序号**seq=u**，用来关闭Client到Server的数据传送，Client进入**FIN_WAIT_1**状态
- 第二次挥手：Server收到**FIN**后，发送一个**ACK=1**，**ack=u+1**，并且带上自己的序列号**seq = v**发送给给Client，Server进入**CLOSE_WAIT**状态。此时**TCP链接处于半关闭状态**，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收
- 第三次挥手：服务器将最后的数据发送完毕后，向客户端发送链接释放报文，Server发送一个**FIN=1**， **ack = u+1**，由于在半关闭状态，服务器可能又发送了一些数据，假定此时序列号为**seq = w**，发送给客户端，用来请求关闭Server到Client的数据传送，Server进入**LAST_ACK**状态。
- 第四次挥手：Client收到**FIN**后，发出确认**ACK = 1,** **ack = w+1**，而自己的序列号为**seq=u+1**，Client进入**TIME_WAIT**状态，此时TCP链接还没释放，必须经过**2MSL**(最长报文段寿命)后，当**客户端撤销相应的TCB**，才进入**CLOSED**状态，Server收到客户端的确认就进入**CLOSED**状态，完成四次挥手。

![](F:\前端总结\个人总结文档\img\1.png)



#### 为什么TCP链接需要三次握手

- 两次不可以么，为什么？

有时候客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接

- 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

- 为什么连接的时候是三次握手，关闭的时候却是四次握手

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手

2.6 如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 计算机编译原理

 编译原理其实就是将高级语言翻译成计算机语言(010101)