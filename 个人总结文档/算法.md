### 算法

#### 基本概念

- 算法稳定性
  - 序列经过算法排序后，原先序列里相同的值之间仍然保持着原先序列的前后顺序，那么该排序算法是稳定排序算法
  - 常见的稳定排序算法有：冒泡、插入、基数排序；
  - 不稳定的排序算法有：选择排序、快速排序、堆积排序、希尔排序

- 原地排序
  - 算法在对序列进行排序的过程中，并未申请额外内存空间，只用原先存储序列数据的内存空间对序列进行交换，比较等操作进行排序，称之为原地排序
  - 原地排序算法：希尔排序、冒泡排序、插入排序、选择排序、堆排序、快速排序
  - 合并排序不是原地排序

#### 选择排序

1. 原理：每次选择最小值(最大值)放在**新的序列的最前面**

   **序列：**   [11, 33, 4, 5, 2, 8]

   **step 1**:   从第一个元素找，选出最小值与第一个元素交换，

   ​                得到新的序列 [**2,** 33, 4, 5, **11**, 8]

   **step 2:**   从第二个元素找，选出序列最小值与第二个元素交换，

   ​				得到新的序列[2, **4**，**33,**  5, 11, 8]

   **step 3:**   从第三个元素找，以此类推

2. 代码

   ```js
   // [2,4,6,3,8,1]
   arr =  [2,4,6,3,8,1];
   for(var i = 0;i < arr.length - 1; i++ ){
       var min = i;
       for (var j = i+1; j < arr.length; j++){
           if (arr[j] < arr[min]){
               min = j;
           }
       }
       if(min != i){
           var temp = arr[i];
           arr[i] = arr[min];
           arr[min] = temp; 
       }
   }
   console.log(arr)
   ```

3. 分析

   - 时间复杂度：`O(n2)`
     - 无论是最坏情况，平均情况，还是最好情况都需要找到最小（大）值
     - 第一轮进行`(n-1)`次比较
     - 第二轮进行`(n-2)`次比较
     - 。。。。
     - 时间复杂度为：`(n-1) + (n-2) + ....1 = n(n-1)/2, O(n2)`

   - 稳定性：不稳定
     - 选择排序是将最大（最小）`直接与前方数字进行交换`，排列顺序可能改变，如 序列5 5 3；因此 **不是稳定的排序算法**
   - 空间复杂度：`O(1)`
     - 只需要一个`额外的空间用于交换`，空间复杂度为O ( 1 ) 

#### 插入排序

1. 原理

   将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。`这样保证稳定性哦`）

   序列   [11, 33, 4, 5, 2, 8]

   **step 1：**得到已排序序列[**11**]

   **step 2:**  得到已排序序列 [**11**, **33**]

   **step 3:**  得到 已排序序列[**4, 11, 33**]

   ......

2.代码

```js
var arr = [11, 33, 4, 5, 2, 8];
for (var i = 1; i < arr.length; i++){
    var point = i-1;
    var current = arr[i];
    while(point >=0 && current < arr[point]){
        arr[point+1] = arr[point];
        point--;
    }
    arr[point+1] = current;
}
console.log(arr);
```



3. 分析

   - 时间复杂度：`n(n-1)/2`
     - 第一次取第二个元素与第一个已排序序列的一个元素比较1次，得到新的排序序列(包含2个元素)
     - 第二次取第三个元素与新的排序序列(包含两个元素)比较2次，得到新的排序序列(包含3个元素)
     - .。。。。。
     - 时间复杂度：1+2+...+(n-1) = n(n-1)/2

   - 空间复杂度：`O(1)`
     - **`只要一个额外交换空间`**

   - 稳定性：**稳定**
     - 每次顺序取待插元素时，若前者与待插入元素大小相同，则自动排在前者后面，**不影响最初顺序**

   

   #### 快速排序

   1. 原理

      **step 1 :**首先拟定第一个元素为**中间值**，从第二个元素开始，设置索引 **i** 从左向右找比中间值大的第一个元素**R**，再设置索引 **j** 从右向左找比中间值小的一个元素**L**。并交换**L/R**位置

      **step 2:**若**i<j**,则继续刚刚的各自寻找任务，找到后并作交换

      **step 3 :**若**i>=j**,则交换**中间值**与**j**索引元素，此时以**中间值**元素的位置为分界点，分为左右独立两个序列，左边序列的数值都比中间值元素小，右边序列的数值都比中间值大。

      **step 4 :**对左右两边序列分别重复**step 1 :**操作(这个排序用到递归操作)

   2. 代码

      ```js
      var arr = [3, 4, 88,2, 5, 55, 9, 1];
      function quickSort(arr,left,right){
          if(left == right){
              return arr
          }
          var len = right - left +1;
          var leftIndex = left+1;
          var rightIndex = len-1;
      
          while(arr[left] > arr[leftIndex]  && leftIndex <=len-1){
              leftIndex++;
          }
          while(arr[left] < arr[rightIndex]  && rightIndex >=1){
              rightIndex--;
          }
      	while(rightIndex > leftIndex){
              arr[leftIndex],arr[rightIndex] = arr[rightIndex],arr[leftIndex];
              while(arr[left] > arr[leftIndex]  && leftIndex <=len-1){
                  leftIndex++;
              }
      		while(arr[left] < arr[rightIndex]  && rightIndex >=1){
          		rightIndex--;
      		} 
          }
          arr[left],arr[rightIndex]=arr[rightIndex],arr[left];
      	
      	quickSort(arr,left,rightIndex-1);
      	quickSort(arr,rightIndex+1,right);
      }
      arr = quickSort(arr,0, arr.length-1)
      console.log(arr)
      ```
      
      
   
   